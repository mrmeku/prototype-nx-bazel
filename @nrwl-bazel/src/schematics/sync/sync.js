"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const workspace_1 = require("@nrwl/workspace");
const ignore = require('ignore');
function createBuildFile(project, depGraph) {
    return schematics_1.apply(schematics_1.url('./files/build-file'), [
        schematics_1.template({ tmpl: '', project, depGraph })
    ]);
}
function updateBuildFile(project, depGraph) {
    return (host, _context) => {
        const buildFile = createBuildFile(project, depGraph);
        const buildFilePath = core_1.join(core_1.normalize(project.root), 'BUILD.bazel');
        return schematics_1.mergeWith(schematics_1.apply(buildFile, [
            sourceHost => {
                if (host.exists(buildFilePath)) {
                    const contents = sourceHost.read('BUILD.bazel').toString();
                    const customPart = host
                        .read(buildFilePath)
                        .toString()
                        .split('# ==== Generated by Nx')[0];
                    host.delete(buildFilePath);
                    sourceHost.overwrite('BUILD.bazel', customPart + contents);
                }
            },
            schematics_1.move(project.root)
        ]), schematics_1.MergeStrategy.Overwrite);
    };
}
function createRootFiles() {
    return host => {
        return schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files/root'), [
            schematics_1.template({
                tmpl: '',
                rootFiles: host
                    .getDir('/')
                    .subfiles.filter(f => f !== 'WORKSPACE' && f !== 'BUILD.bazel'),
                name: workspace_1.readJsonInTree(host, '/package.json').name.replace('-', '_')
            }),
            () => {
                if (host.exists('WORKSPACE')) {
                    host.delete('WORKSPACE');
                }
                if (host.exists('.bazelrc')) {
                    host.delete('.bazelrc');
                }
                if (host.exists('nx.bzl')) {
                    host.delete('nx.bzl');
                }
                if (host.exists('BUILD.bazel')) {
                    host.delete('BUILD.bazel');
                }
            }
        ]), schematics_1.MergeStrategy.Overwrite);
    };
}
function addNpmPackagePatches() {
    return host => {
        return schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files/patches'), [
            schematics_1.template({
                tmpl: '',
                rootFiles: host
                    .getDir('/')
                    .subfiles.filter(f => f !== 'WORKSPACE' && f !== 'BUILD.bazel'),
                name: workspace_1.readJsonInTree(host, '/package.json').name.replace('-', '_')
            }),
            () => {
                if (host.exists('patches')) {
                    host.delete('patches');
                }
            }
        ]), schematics_1.MergeStrategy.Overwrite);
    };
}
function addRequiredPackages() {
    const devDeps = {
        'patch-package': '^6.2.0',
        '@bazel/bazel': '^1.2.0',
        '@bazel/ibazel': '0.10.3'
    };
    return workspace_1.updateJsonInTree('package.json', (json, context) => {
        if (!json.scripts) {
            json.scripts = {};
        }
        if (json.scripts.postinstall) {
            if (!json.scripts.postinstall.includes('patch-package')) {
                json.scripts.postinstall = `patch-package && ${json.script.postinstall}`;
            }
        }
        else {
            json.scripts.postinstall = 'patch-package';
        }
        Object.keys(devDeps).forEach(key => {
            if (json.dependencies) {
                delete json.dependencies[key];
            }
            if (json.devDependencies) {
                delete json.devDependencies[key];
            }
        });
        json.devDependencies = Object.assign({}, (json.devDependencies || {}), devDeps);
        context.addTask(new tasks_1.NodePackageInstallTask());
        return json;
    });
}
function updateGitIgnore() {
    return host => {
        if (!host.exists('.gitignore')) {
            return;
        }
        const ig = ignore();
        ig.add(host.read('.gitignore').toString());
        if (!ig.ignores('bazel-out')) {
            const content = `${host
                .read('.gitignore')
                .toString('utf-8')
                .trimRight()}\nbazel-*\n`;
            host.overwrite('.gitignore', content);
        }
    };
}
exports.default = () => {
    return (host) => {
        const depGraph = workspace_1.getDependencyGraphFromTree(host);
        return schematics_1.chain([
            createRootFiles(),
            addNpmPackagePatches(),
            addRequiredPackages(),
            updateGitIgnore(),
            ...Object.values(depGraph.projects).map(project => updateBuildFile(project, depGraph))
        ]);
    };
};
